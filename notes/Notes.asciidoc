= Ubiquiti airCube ISP
:toc:
:toc-placement: preamble

// Need some preamble to get TOC:
{empty}

== Hardware

=== Info

|===
| **Instruction set:**                   | MIPS
| **Vendor:**                            | Qualcomm Atheros
| **Bootloader:**                        | U-Boot
| **System-On-Chip:**                    | Qualcomm / Atheros QCA9533-BL3A (MIPS 24Kc)
| **CPU Frq**                            | 650MHz
| **Flash size:**                        | 16 MiB
| **Flash Chip:**                        | Macronix MX25L12835FMT
| **RAM size:**                          | 64 MiB
| **RAM Chip:**                          | Winbond W9751G6KB-25
| **Wireless:**                          | __SoC-integrated__: QCA9533
| **Ethernet:**                          | 1 port connected to the CPU
| **USB:**                               | No
| **Power:**                             | USB or PoE
| **Serial:**                            | via pinheader
|===

image:pictures/aircube_closed.jpg[width=600]

=== Opening the case

There are two clips on each side (total of eight). See the red arrows in the
image for the locations. Carefully lift the case right above the transparent LED
plastic. Note: The surface of the case scratches quite easily. So be careful if
you want to avoid scratches.

image:pictures/aircube_opened.jpg[width=600]

=== Serial

image:pictures/aircube_serial.jpg[width=600]

Baudrate: 115200

=== LED-Controller

There is a small 10 pin SONiX 8-Bit microcontroller (8F26E611LA) on the board.
I did an analysis with the method every sane person would use: Soldering wires
to all IO-Pins to hook up a logic analyzer.

image:pictures/aircube_SONiX_logic_analyzer.jpg[width=600]

The logic analyzer is hooked up in a way that Pin 1 to 7 are analyzed as channel
1 to 7.

image:pictures/aircube_SONiX_pinout.jpg[width=600]

Overview over the boot process:

image:pictures/aircube_SONiX_logic_boot.png[width=1200]

Pin 2: Seems to control the LED. The PWM on that pin matches the pulsing of the
LED during boot.

Pressing the reset button changes the LED pattern but is not visible on any pin.
The same is true for setting PoE Passthrough in the web interface.

Pin 1, 5, 6 and 7 are quite clearly a SPI communication. The mode seems to be
CPOL = 0, CPHA = 0 (clock low when idle, data valid on rising edge). CS is
active low. In the following I decode as MSB first. The clock rate is about
98 kHz.

image:pictures/aircube_SONiX_zoom_to_one_data_byte.png[width=1200]

So the pinout is:

* Pin 1: SPI chip select
* Pin 2: PWM for LED
* Pin 3 and 4: Seems to be unused.
* Pin 5: SPI MISO
* Pin 6: SPI MOSI
* Pin 7: SPI SCK

The SPI pins are connected to the following SoC-pins:

* CS: GPIO 1
* MISO: ?
* MOSI: GPIO 2
* SCK: GPIO 3

Known MOSI values on SPI (from various patterns / strings in the uh_leds module):

* 0x00: Switch LED off (set via via web interface, seen during boot)
* 0x0F: Dim led (about 20% on)
* 0x2F: PWM to about 70%
* 0x3F: PWM to about 95%
* 0x45: Pulsing pattern (0% PWM -> 95% PWM -> 0% PWM in about 0.55s)
* 0x55: Pulsing pattern during boot (0% PWM -> 95% PWM in about 2.2s)
* 0x5F: Pulsing pattern during boot (0% PWM -> 95% PWM -> 0% PWM in about 3.2s)
* 0x83: Fast pulsing pattern during reset pressed on power up (dim -> bright in
  about 0.2s)

MISO seems to repeat the last sent value.

The original module for the leds (+uh_leds+) allows to echo the text +test+
followed by a hex number to be put to +/proc/sys/uh_leds+. That sends the hex
number to the SPI bus.

*Assumption:*

Higher two bits set a mode. Lower six bits are a parameter.

* Mode: 00 -> set brightness between 0x00 (min) and 0x3F (max)
* Mode: 01 -> pulsing pattern (min -> max -> min) with an interval. From some
  tests, the period is about (50ms + 102ms * parameter). There is a slightly
  different pattern starting from <mode> + 0x10 (longer gap between the pulses)
  but the time still follows that calculation.
* Mode: 10 -> same as 01 but with only a ramp from min to max. Again a slight
  jump in the pattern at <mode> + 0x10.
* Mode: 11 -> blinking (off -> 25% -> off -> 25% -> ...) with a period of 
  (105ms * parameter)

== OEM firmware

The original firmware is based on OpenWRT.

Tested firmware version: ACB.ar934x.v2.4.0.cb22320.180904.1044

.Bootlog
----
U-Boot 1.1.4-s1055 (Sep 19 2017 - 16:00:36)

DRAM:  64 MB
Flash: 16 MB (0xc2, 0 0x20, 0x18)
*** Warning *** : PCIe WLAN Module not found !!!
In:    serial
Out:   serial
Err:   serial
Net:   eth0, eth1
Board: Ubiquiti Networks QCA953X board (e8f7-148738.0160.0030)
Radio: 0777:e8f7
Hit any key to stop autoboot:  0 
## Booting image at 9f050000 ...
   Image Name:   MIPS OpenWrt Linux-4.1.16
   Created:      2018-09-04   5:28:33 UTC
   Image Type:   MIPS Linux Kernel Image (lzma compressed)
   Data Size:    1280210 Bytes =  1.2 MB
   Load Address: 80060000
   Entry Point:  80060000
   Verifying Checksum at 0x9f050040 ...OK
   Uncompressing Kernel Image ... OK

Starting kernel ...

[    0.000000] Linux version 4.1.16 (jenkins@9284c466547f) (gcc version 5.2.0 (OpenWrt GCC 5.2.0 r48688) ) #1 Tue Sep 4 10:44:06 EEST 2018
[    0.000000] flash_size passed from bootloader = 16
[    0.000000] bootconsole [early0] enabled
[    0.000000] CPU0 revision is: 00019374 (MIPS 24Kc)
[    0.000000] SoC: Qualcomm Atheros QCA9533 ver 2 rev 0
[    0.000000] Determined physical RAM map:
[    0.000000]  memory: 04000000 @ 00000000 (usable)
[    0.000000] User-defined physical RAM map:
[    0.000000]  memory: 04000000 @ 00000000 (usable)
[    0.000000] Initrd not found or empty - disabling initrd
[    0.000000] Zone ranges:
[    0.000000]   Normal   [mem 0x0000000000000000-0x0000000003ffffff]
[    0.000000] Movable zone start for each node
[    0.000000] Early memory node ranges
[    0.000000]   node   0: [mem 0x0000000000000000-0x0000000003ffffff]
[    0.000000] Initmem setup node 0 [mem 0x0000000000000000-0x0000000003ffffff]
[    0.000000] Primary instruction cache 64kB, VIPT, 4-way, linesize 32 bytes.
[    0.000000] Primary data cache 32kB, 4-way, VIPT, cache aliases, linesize 32 bytes
[    0.000000] Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 16256
[    0.000000] Kernel command line: console=ttyS0,115200 root=31:03 rootfstype=squashfs init=/sbin/init panic=3 board=AIRCUBE mtdparts=spi0.0:256k(u-boot),64k(u-boot-env),4096k(kernel),11648k(rootfs),256k(cfg),64k(EEPROM) mem=64M
[    0.000000] PID hash table entries: 256 (order: -2, 1024 bytes)
[    0.000000] Dentry cache hash table entries: 8192 (order: 3, 32768 bytes)
[    0.000000] Inode-cache hash table entries: 4096 (order: 2, 16384 bytes)
[    0.000000] Writing ErrCtl register=00000000
[    0.000000] Readback ErrCtl register=00000000
[    0.000000] Memory: 60292K/65536K available (2859K kernel code, 144K rwdata, 712K rodata, 240K init, 266K bss, 5244K reserved, 0K cma-reserved)
[    0.000000] SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
[    0.000000] NR_IRQS:83
[    0.000000] Clocks: CPU:650.000MHz, DDR:390.844MHz, AHB:216.666MHz, Ref:25.000MHz
[    0.000000] clocksource MIPS: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 5880801374 ns
[    0.000009] sched_clock: 32 bits at 325MHz, resolution 3ns, wraps every 6607641598ns
[    0.007454] Calibrating delay loop... 432.53 BogoMIPS (lpj=2162688)
[    0.069990] pid_max: default: 32768 minimum: 301
[    0.074511] Security Framework initialized
[    0.078388] TOMOYO Linux initialized
[    0.081842] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes)
[    0.088097] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes)
[    0.098225] clocksource jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns
[    0.108373] NET: Registered protocol family 16
[    0.114108] MIPS: machine is Ubiquiti airCube
[    0.146647] ar724x-pci ar724x-pci.0: PCIe link is down
[    0.151547] registering PCI controller with io_map_base unset
[    0.156992] Ubiquiti airCube ISP
[    0.602253] PCI host bridge to bus 0000:00
[    0.606125] pci_bus 0000:00: root bus resource [mem 0x10000000-0x11ffffff]
[    0.612723] pci_bus 0000:00: root bus resource [io  0x0000]
[    0.618010] pci_bus 0000:00: root bus resource [??? 0x00000000 flags 0x0]
[    0.624508] pci_bus 0000:00: No busn resource found for root bus, will use [bus 00-ff]
[    0.633043] Switched to clocksource MIPS
[    0.638530] NET: Registered protocol family 2
[    0.643705] TCP established hash table entries: 1024 (order: 0, 4096 bytes)
[    0.650336] TCP bind hash table entries: 1024 (order: 0, 4096 bytes)
[    0.656470] TCP: Hash tables configured (established 1024 bind 1024)
[    0.662612] UDP hash table entries: 256 (order: 0, 4096 bytes)
[    0.668198] UDP-Lite hash table entries: 256 (order: 0, 4096 bytes)
[    0.674553] NET: Registered protocol family 1
[    0.679889] futex hash table entries: 256 (order: -1, 3072 bytes)
[    0.705530] squashfs: version 4.0 (2009/01/31) Phillip Lougher
[    0.711067] jffs2: version 2.2 (NAND) (SUMMARY) (LZMA) (RTIME) (CMODE_PRIORITY) (c) 2001-2006 Red Hat, Inc.
[    0.723310] io scheduler noop registered
[    0.727007] io scheduler deadline registered (default)
[    0.732135] Serial: 8250/16550 driver, 1 ports, IRQ sharing disabled
ï¿½[    0.762228] serial8250.0: ttyS0 at MMIO 0x18020000 (irq = 11, base_baud = 1562500) is a 16550A
[    0.770439] console [ttyS0] enabled
[    0.770439] console [ttyS0] enabled
[    0.777585] bootconsole [early0] disabled
[    0.777585] bootconsole [early0] disabled
[    0.789618] m25p80 spi0.0: found mx25l12805d, expected m25p80
[    0.796785] m25p80 spi0.0: mx25l12805d (16384 Kbytes)
[    0.802047] 6 cmdlinepart partitions found on MTD device spi0.0
[    0.808210] Creating 6 MTD partitions on "spi0.0":
[    0.813189] 0x000000000000-0x000000040000 : "u-boot"
[    0.819372] 0x000000040000-0x000000050000 : "u-boot-env"
[    0.825812] 0x000000050000-0x000000450000 : "kernel"
[    0.831801] 0x000000450000-0x000000fb0000 : "rootfs"
[    0.837807] mtd: device 3 (rootfs) set to be root filesystem
[    0.843742] 0x000000fb0000-0x000000ff0000 : "cfg"
[    0.849439] 0x000000ff0000-0x000001000000 : "EEPROM"
[    0.881023] libphy: ag71xx_mdio: probed
[    1.476007] ag71xx ag71xx.0: connected to PHY at ag71xx-mdio.1:04 [uid=004dd042, driver=Generic PHY]
[    1.486289] eth0: Atheros AG71xx at 0xb9000000, irq 4, mode:MII
[    2.075604] ag71xx-mdio.1: Found an AR934X built-in switch
[    2.119035] eth1: Atheros AG71xx at 0xba000000, irq 5, mode:GMII
[    2.127067] NET: Registered protocol family 10
[    2.135503] NET: Registered protocol family 17
[    2.140191] bridge: automatic filtering via arp/ip/ip6tables has been deprecated. Update your scripts to load br_netfilter if you need this.
[    2.153439] 8021q: 802.1Q VLAN Support v1.8
[    2.167114] VFS: Mounted root (squashfs filesystem) readonly on device 31:3.
[    2.176464] Freeing unused kernel memory: 240K (80404000 - 80440000)
[    2.207999] Calling /sbin/tomoyo-init to load policy. Please wait.
15 domains. 17 A[    3.279985] TOMOYO: 2.5.0
CL entries.
32 [    3.283271] Mandatory Access Control activated.
KB used by policy.
[    3.679212] init: Console is alive
[    3.683201] init: - watchdog -
[    5.627844] kmodloader: loading kernel modules from /etc/modules-boot.d/*
[    5.808710] ubnthal: module license 'Proprietary' taints kernel.
[    5.815013] Disabling lock debugging due to kernel taint
[    5.896000] ubnthal: initializing...
[    5.899758] ubnthal: initialised, board found, sysid = 0xe8f7, name = airCube ISP
[    5.907514] ubnthal: host_board_t size: 7320B, boards table size: 14kB
[    5.938486] usbcore: registered new interface driver usbfs
[    5.944348] usbcore: registered new interface driver hub
[    5.949956] usbcore: registered new device driver usb
[    5.961798] ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver
[    5.970444] ehci-platform: EHCI generic platform driver
[    5.976044] ehci-platform ehci-platform: EHCI Host Controller
[    5.982025] ehci-platform ehci-platform: new USB bus registered, assigned bus number 1
[    5.992359] ehci-platform ehci-platform: irq 3, io mem 0x1b000000
[    6.013084] ehci-platform ehci-platform: USB 2.0 started, EHCI 1.00
[    6.020569] hub 1-0:1.0: USB hub found
[    6.024918] hub 1-0:1.0: 1 port detected
[    6.032767] ohci_hcd: USB 1.1 'Open' Host Controller (OHCI) Driver
[    6.041057] ohci-platform: OHCI generic platform driver
[    6.047461] kmodloader: done loading kernel modules from /etc/modules-boot.d/*
[    6.065608] init: - preinit -
Please press Enter to activate this console.


airCube-ISP login: ubnt
Password: 


BusyBox v1.24.1 () built-in shell (ash)

       _      _____ Ubiquiti
      (_)    /  __ \     | |
  __ _ _ _ __| /  \/_   _| |__   ___
 / _` | | '__| |   | | | | '_ \ / _ \
| (_| | | |  | \__/\ |_| | |_) |  __/
 \__,_|_|_|   \____/\__,_|_.__/ \___|
    Dirty Diamond v2.4.0        cb22320.180904.1044
ubnt@airCube-ISP:/# uname -a
Linux airCube-ISP 4.1.16 #1 Tue Sep 4 10:44:06 EEST 2018 mips GNU/Linux
ubnt@airCube-ISP:~# cat /proc/cpuinfo 
system type             : Qualcomm Atheros QCA9533 ver 2 rev 0
machine                 : Ubiquiti airCube
processor               : 0
cpu model               : MIPS 24Kc V7.4
BogoMIPS                : 432.53
wait instruction        : yes
microsecond timers      : yes
tlb_entries             : 16
extra interrupt vector  : yes
hardware watchpoint     : yes, count: 4, address/irw mask: [0x0ffc, 0x0ffc, 0x0ffb, 0x0ffb]
isa                     : mips1 mips2 mips32r1 mips32r2
ASEs implemented        : mips16
shadow register sets    : 1
kscratch registers      : 0
package                 : 0
core                    : 0
VCED exceptions         : not available
VCEI exceptions         : not available

ubnt@airCube-ISP:~# 
----

You can login with the user `ubnt` and the password printed on the label on the
bottom of the device.

.Infos from U-Boot
----
U-Boot 1.1.4-s1055 (Sep 19 2017 - 16:00:36)

DRAM:  64 MB
Flash: 16 MB (0xc2, 0 0x20, 0x18)
*** Warning *** : PCIe WLAN Module not found !!!
In:    serial
Out:   serial
Err:   serial
Net:   eth0, eth1
Board: Ubiquiti Networks QCA953X board (e8f7-148738.0160.0030)
Radio: 0777:e8f7
Hit any key to stop autoboot:  0 
ath> printenv
bootdelay=1
baudrate=115200
ethaddr=0x00:0xaa:0xbb:0xcc:0xdd:0xee
ubntctrl=enabled
serverip=192.168.1.254 
mtdparts=mtdparts=spi0.0:256k(u-boot),64k(u-boot-env),4096k(kernel),11648k(rootfs),256k(cfg),64k(EEPROM)
bootcmd=bootm 0x9f050000
bootargs=console=ttyS0,115200 root=31:03 rootfstype=squashfs init=/sbin/init panic=3 board=AIRCUBE
ipaddr=192.168.1.20 
stdin=serial
stdout=serial
stderr=serial
ubntaddr=80200020
appinitdone=true
ethact=eth0

Environment size: 445/65532 bytes
ath> bdinfo
boot_params = 0x83F7BFB0
memstart    = 0x80000000
memsize     = 0x04000000
flashstart  = 0x9F000000
flashsize   = 0x01000000
flashoffset = 0x00028DF4
ethaddr     = 00:AA:BB:CC:DD:EE
ip_addr     = 192.168.1.20
baudrate    = 115200 bps
ath> mtdparts

device nor0 <spi0.0>, # parts = 6
 #: name                        size            offset          mask_flags
 0: u-boot                      0x00040000      0x00000000      0
 1: u-boot-env                  0x00010000      0x00040000      0
 2: kernel                      0x00400000      0x00050000      0
 3: rootfs                      0x00b60000      0x00450000      0
 4: cfg                         0x00040000      0x00fb0000      0
 5: EEPROM                      0x00010000      0x00ff0000      0

active partition: nor0,0 - (u-boot) 0x00040000 @ 0x00000000

defaults:
mtdids  : nor0=spi0.0
mtdparts: mtdparts=spi0.0:256k(u-boot),64k(u-boot-env),4096k(kernel),11648k(rootfs),256k(cfg),64k(EEPROM)
ath> 
----

=== Flash layout

The flash layout is given by the mtdparts U-Boot command in the above log. Alternatively it can be found in the original firmware:

----
ubnt@airCube-ISP:~# cat /proc/mtd 
dev:    size   erasesize  name
mtd0: 00040000 00010000 "u-boot"
mtd1: 00010000 00010000 "u-boot-env"
mtd2: 00400000 00010000 "kernel"
mtd3: 00b60000 00010000 "rootfs"
mtd4: 00040000 00010000 "cfg"
mtd5: 00010000 00010000 "EEPROM"
ubnt@airCube-ISP:~# 
----

The used
chip is a NOR flash. So according to
https://openwrt.org/docs/techref/flash.layout it's possible to use a SquashFS.

The original flash layout is quite similar to other ubiquity devices like the
https://openwrt.org/inbox/ubiquiti/ubiquiti_nanostation_ac.

=== Finding the Original mac Address

.Unchanged ifconfig
----
ubnt@airCube-ISP:~# ifconfig -a
lan0      Link encap:Ethernet  HWaddr B6:FB:E4:63:2C:2D  
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:100 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
          Interrupt:5 

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:20 errors:0 dropped:0 overruns:0 frame:0
          TX packets:20 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:1532 (1.4 KiB)  TX bytes:1532 (1.4 KiB)

wan0      Link encap:Ethernet  HWaddr B4:FB:E4:63:2C:2D  
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:100 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
          Interrupt:4 

wlan0     Link encap:Ethernet  HWaddr B4:FB:E4:62:2C:2D  
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
----

There is a command `progmac` and `progmac2` in the U-Boot. Calling `progmac`
delivers the following output:

----
ath> help progmac
progmac progmac <serno> [<product_id>] - Program the MAC addresses
                <serno> is the value of the last
                4 digits (decimal) of the serial number.
                Optional parameter <product_id> specifies
                the board's product ID (decimal)

ath> progmac

First 0xff last 0xff sector size 0x10000
 255
write addr: 9fff0000
ath> boot
----

Now after booting the `ifconfig` output changes. But it's a little unclear how
the serial number is processed (even if one is given).

.ifconfig output after progmac
----
ubnt@airCube-ISP:~# ifconfig -a
lan0      Link encap:Ethernet  HWaddr 00:03:7F:11:20:01  
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:100 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
          Interrupt:5 

lo        Link encap:Local Loopback  
          LOOPBACK  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

wan0      Link encap:Ethernet  HWaddr 00:03:7F:11:20:00  
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:100 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
          Interrupt:4 

wlan0     Link encap:Ethernet  HWaddr B4:FB:E4:62:2C:2D  
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

ubnt@airCube-ISP:~# 
----

`progmac2` seems to be a little more direct:

----
ath> help progmac2
progmac2 progmac2 <eth0 mac> <eth1 mac> - Program the MAC addresses
                  <eth0 mac> is the eth0 MAC address
                  <eth1 mac> is the eth1 MAC address
                  MAC address can be in the format
                  <aa:bb:cc:dd:ee:ff> or <aabbccddeeff>
ath> progmac2
Usage:
progmac2 - Set ethernet MAC addresses

progmac2 <eth0 mac> <eth1 mac>
ath> progmac2 B4:FB:E4:63:2C:2D B6:FB:E4:63:2C:2D
b4:fb:e4:63:2c:2d
b4fbe463 2c2d0000
b6:fb:e4:63:2c:2d
b6fbe463 2c2d0000

First 0xff last 0xff sector size 0x10000
 255
write addr: 9fff0000
ath>
----

After the addresses are back to normal:

----
ubnt@airCube-ISP:~# ifconfig -a
lan0      Link encap:Ethernet  HWaddr B6:FB:E4:63:2C:2D  
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:100 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
          Interrupt:5 

lo        Link encap:Local Loopback  
          LOOPBACK  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

wan0      Link encap:Ethernet  HWaddr B4:FB:E4:63:2C:2D  
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:100 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
          Interrupt:4 

wlan0     Link encap:Ethernet  HWaddr B4:FB:E4:62:2C:2D  
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

ubnt@airCube-ISP:~# 
----

The output of progmac (or progmac2) gives a hint where the addresses are stored:

----
ath> md 0x9fff0000
9fff0000: b4fbe463 2c2db6fb e4632c2d e8f70777    ...c,-...c,-...w
9fff0010: 00024502 ffff000d ffffffff ffffffff    ..E.............
9fff0020: 41495243 55424500 00000000 00000000    AIRCUBE.........
9fff0030: 44413652 4a42724e 787773ff ffffffff    DA6RJBrNxws.....
9fff0040: ffffffff ffffffff ffffffff ffffffff    ................
9fff0050: 24312434 36314c75 49423924 47376477    $1$461LuIB9$G7dw
9fff0060: 3162526c 44662f63 4c386542 6144695a    1bRlDf/cL8eBaDiZ
9fff0070: 5031ffff ffffffff ffffffff ffffffff    P1..............
9fff0080: ffffffff ffffffff ffffffff ffffffff    ................
9fff0090: ffffffff ffffffff ffffffff ffffffff    ................
9fff00a0: ffffffff ffffffff ffffffff ffffffff    ................
9fff00b0: ffffffff ffffffff ffffffff ffffffff    ................
9fff00c0: ffffffff ffffffff ffffffff ffffffff    ................
9fff00d0: ffffffff ffffffff ffffffff ffffffff    ................
9fff00e0: ffffffff ffffffff ffffffff ffffffff    ................
9fff00f0: ffffffff ffffffff ffffffff ffffffff    ................
ath> 
----

The Address for wan0 is at 0x9fff0000. The one for lan0 is at 0x9fff0006.

Beneath that there is a WLAN configuration ROM at 0x9fff1000:

----
ath> md 0x9fff1000
9fff1000: 0202b4fb e4622c2d 00000000 00000000    .....b,-........
9fff1010: 00000000 00000000 00000000 00001f00    ................
9fff1020: 33020000 00000400 18004d04 030008ff    3.........M.....
9fff1030: 11000000 00200220 00111111 00500150    ..... . .....P.P
9fff1040: 01500100 00000000 00140064 7da4af00    .P.........d}...
9fff1050: ff000000 00000000 00000000 00000000    ................
9fff1060: 0e0e0300 2ce20002 0e1c80c0 800c80c0    ....,...........
9fff1070: 80000000 00000000 00000000 00000000    ................
9fff1080: 00000000 00000000 00007089 a2ee0081    ..........p.....
9fff1090: 000000ef 00820000 00f10084 000000eb    ................
9fff10a0: 007e0000 00ed007f 000000ee 007f0000    .~..............
9fff10b0: 00000000 00000000 00000000 00000000    ................
9fff10c0: 00000070 ac7089ac 7089ac70 89ac2222    ...p.p..p..p..""
9fff10d0: 22222222 22222222 201a2222 201a2222    """""""" ."" .""
9fff10e0: 201a2222 201e1c1a 201e1c1a 20201c14     ."" ... ...  ..
9fff10f0: 2222201e 1c1a201e 1c1a2020 1c142222    "" ... ...  ..""
ath> 
----
The wlan MAC is at 0x9fff1002.

== PoE pass through

The PoE pass through can most likely be enabled / disabled with GPIO 11. This
assumption is based on the following:

There is a ubnt_hwctl service in the original firmware that controlls the poe
passthrough:

----
#!/bin/sh /etc/rc.common
# Copyright (C) 2015 OpenWrt.org

START=15
STOP=10
USE_PROCD=1


get_gpio_pin()
{
        feature_poe=`grep -c "feature_poe_passthrough=1" /proc/ubnthal/board.inc`
        if [ "$feature_poe" != "0" ];
        then
                rv=`sed -ne 's/^$poe_passthrough_gpio=\(.*\);$/\1/p' /proc/ubnthal/board.inc`
        fi

        [ -z $rv ] && gpio_pin=0 || gpio_pin=$rv
}


setup_hwctl()
{
        local poe_enable
        local gpio_pin

        get_gpio_pin

        config_get poe_enable "$1" poe_pass 0

        if [ -n $gpio_pin -a "$gpio_pin" != "0" ]; then

                local gpio_path="/sys/class/gpio/gpio${gpio_pin}"
                # export GPIO pin for access
                [ -d "$gpio_path" ] || {
                        echo $gpio_pin > /sys/class/gpio/export
                        # we need to wait a bit until the GPIO appears
                        [ -d "$gpio_path" ] || sleep 1
                        echo out >"$gpio_path/direction"
                }
                # write 0 or 1 to the "value" field
                { [ "$poe_enable" = "0" ] && echo "0" || echo "1"; } >"$gpio_path/value"
        fi
}

service_triggers()
{
        procd_add_reload_trigger "ubnt"
}

start_service()
{
        [ -e /proc/ubnthal/board.inc ] && {
                config_load ubnt
                config_foreach setup_hwctl hwctl
        }
}

stop_service()
{
        [ -e /proc/ubnthal/board.inc ] && {
                local gpio_pin
                get_gpio_pin

                if [ -n $gpio_pin -a "$gpio_pin" != "0" ]; then
                        local gpio_path="/sys/class/gpio/gpio${gpio_pin}"
                        [ -f "$gpio_path/value" ] && echo "0" >"$gpio_path/value"
                fi
        }
}
----

This service uses some of the /proc/ubnthal files:

----
ubnt@airCube-ISP:/etc/init.d# cat /proc/ubnthal/board.inc 
<?
$board_id="0xe8f7";
$cpu_revision="0x00000160";
$board_name="airCube ISP";
$board_raw_name="airCube ISP";
$board_shortname="ACB";
$board_model="ACB-ISP";
$board_timestamp="1533689463";
$board_bom="13-00581-02";
$board_hwaddr="B4FBE4622C2D";
$board_netmodes=7;
$reboot_time=40;
$upgrade_time=150;
$radio_count=2;
$radio1_name="";
$radio1_shortname="";
$radio1_bus="pci";
$radio1_devdomain=2400;
$radio1_ccode=840;
$radio1_ccode_fixed=0;
$radio1_ccode_locked=0;
$radio1_subsystemid="0xe8f7";
$radio1_subvendorid="0x0777";
$radio1_txpower_max=19;
$radio1_txpower_min=0;
$radio1_txpower_offset=0;
$radio1_low_txpower_atten=0;
$radio1_low_txpower_limit=0;
$radio1_ieee_modes=21;
$radio1_ieee_mode="auto";
$radio1_ant_count=1;
$radio1_def_antenna=1;
$radio1_ant_id[0]=1;
$radio1_ant_name[0]=dict_translate("Feed only");
$radio1_ant_gain[0]=3;
$radio1_ant_builtin[0]=1;
$radio1_caps=752877588;
$radio1_eirp_limit=0;
$radio1_distance_limit_km=0;
$radio1_regdomain_flags="bom=0x0,ts=0x5b6a3e77";
$radio1_chains=2;
$radio1_ieee_mode_a=1;
$radio1_low_txpower_mode=0;
$radio1_legacy=0;
$radio1_chanbw="20,40";
$radio1_ext_channel=1;
$radio1_ptp_only=1;
$radio1_ptp_sta=1;
$radio1_ptmp_only=1;
$radio1_ptmp_sta=1;
$radio2_name="";
$radio2_shortname="";
$radio2_bus="ahb";
$radio2_devdomain=0;
$radio2_ccode=0;
$radio2_ccode_fixed=0;
$radio2_ccode_locked=0;
$radio2_subsystemid="0x0000";
$radio2_subvendorid="0x0000";
$radio2_txpower_max=0;
$radio2_txpower_min=0;
$radio2_txpower_offset=0;
$radio2_low_txpower_atten=0;
$radio2_low_txpower_limit=0;
$radio2_ieee_modes=0;
$radio2_ieee_mode="11naht";
$radio2_ant_count=0;
$radio2_def_antenna=0;
$radio2_caps=0;
$radio2_eirp_limit=0;
$radio2_distance_limit_km=0;
$radio2_regdomain_flags="bom=0x0,ts=0x5b6a3e77";
$radio2_chains=1;
$radio2_low_txpower_mode=0;
$radio2_legacy=1;
$radio2_chanbw="5,10,20,40,80";
$radio2_ext_channel=1;
$radio_outdoor=1;
$feature_advanced_ethernet=1;
$feature_poe_passthrough=1;
$poe_passthrough_gpio=11;
$feature_advanced_ethernet_phy=1;
$feature_ext_reset=0;
$eth_mac_count=1;
$eth_mac1_max_mtu=2024;
$feature_rssi_leds=0;
>
ubnt@airCube-ISP:/etc/init.d# cat /proc/ubnthal/board.info 
board.sysid=0xe8f7
board.cpurevision=0x00000160
board.name=airCube ISP
board.shortname=ACB
board.model=ACB-ISP
board.timestamp=1533689463
board.bom=13-00581-02
board.netmodes=7
board.hwaddr=B4FBE4622C2D
board.reboot=40
board.upgrade=150
board.phycount=1
board.phy.1.maxmtu=2024
board.fcc_unii_activated=0
board.fcc_unii_switchable=0
radio.1.name=
radio.1.shortname=
radio.1.bus=pci
radio.1.subsystemid=0xe8f7
radio.1.subvendorid=0x0777
radio.1.txpower.max=19
radio.1.txpower.min=0
radio.1.txpower.offset=0
radio.1.ieee_modes=21
radio.1.antennas=1
radio.1.def_antenna=1
radio.1.antenna.1.id=1
radio.1.antenna.1.name=Feed only
radio.1.antenna.1.gain=3
radio.1.antenna.1.builtin=1
radio.1.caps=752877588
radio.1.eirp.limit=0
radio.1.regdomain_flags="bom=0x0,ts=0x5b6a3e77"
radio.1.devdomain=2400
radio.1.ccode=840
radio.1.ccode_fixed=0
radio.1.ccode_locked=0
radio.1.ptp_only=1
radio.1.ptp_sta=1
radio.1.ptmp_only=1
radio.1.ptmp_sta=1
radio.1.distance_limit_km=0
radio.1.chanbw="20,40"
radio.2.name=
radio.2.shortname=
radio.2.bus=ahb
radio.2.subsystemid=0x0000
radio.2.subvendorid=0x0000
radio.2.txpower.max=0
radio.2.txpower.min=0
radio.2.txpower.offset=0
radio.2.ieee_modes=0
radio.2.antennas=0
radio.2.def_antenna=0
radio.2.caps=0
radio.2.eirp.limit=0
radio.2.regdomain_flags="bom=0x0,ts=0x5b6a3e77"
radio.2.devdomain=0
radio.2.ccode=0
radio.2.ccode_fixed=0
radio.2.ccode_locked=0
radio.2.distance_limit_km=0
radio.2.chanbw="5,10,20,40,80"
feature.rssi.leds=0
feature.ext_reset=0
ubnt@airCube-ISP:/etc/init.d#
----

== Flashing OpenWRT

I now have a version of the repository that can build an image:

https://github.com/c-mauderer/openwrt/tree/adac76074a5900f02bfaca76f530e84958533e01

Sadly the first tries flashing that image via the web interface didn't work. The
same is true for TFTP recovery mode.

The TFTP recovery mode can either be activated by a (really) long press on the
reset button or by typing `urescue` into the U-Boot console.

For a self-made image the following is printed:

----
ath> urescue
eth0 link down
enet1 port1 up
dup 1 speed 1000
Setting default IP 192.168.1.20
Starting TFTP server...
Using eth1 (192.168.1.20), address: 0x81000000
Waiting for connection: |
Receiving file from 192.168.1.5:59574
Received 3670020 bytes
Firmware check failed! (1)
----

The output when flashing an official Ubiquity image is as follows:

----
ath> urescue
eth0 link down
enet1 port1 up
dup 1 speed 1000
Setting default IP 192.168.1.20
Starting TFTP server...
Using eth1 (192.168.1.20), address: 0x81000000
Waiting for connection: -
Receiving file from 192.168.1.5:40891
Received 7106306 bytes
Firmware Version: ACB.ar934x.v2.4.0.cb22320.180904.1044
 RSA Signed Image. Verifying please wait... 
 Decrypted Hash:  34 dc df b7 cc c2 da 57 cd 24 5f e1 d5 d4 c7 1a f7 3b d8 94
 Image Hash:      34 dc df b7 cc c2 da 57 cd 24 5f e1 d5 d4 c7 1a f7 3b d8 94
 Image Signature Verified, Success.
Setting U-Boot environment variables
Un-Protected 1 sectors
Erasing Flash...Erasing flash... 
First 0x4 last 0x4 sector size 0x10000
   4
Erased 1 sectors
Writing to Flash... write addr: 9f040000
done
Protected 1 sectors
Valid 'extra' partition found
Will not use 'u-boot' partition data! Skipped.
Copying partition 'kernel' to flash memory:

First 0x5 last 0x44 sector size 0x10000
................................................................ done
write addr: 9f050000
Copying partition 'rootfs' to flash memory:

First 0x45 last 0xfa sector size 0x10000
...................................................................................................................................................................................... done
write addr: 9f450000
Will not use 'extras' partition data. Skipped.

Firmware update complete.

U-Boot 1.1.4-s1055 (Sep 19 2017 - 16:00:36)

DRAM:  64 MB
----

So it seems that there is at least some basic check and after that there is an
RSA check. If the RSA check isn't mandatory, it might could be possible to
re-create an image.

=== Image Format Analysis

This Analysis tries to find out the image format. The original image used here
is the ACB.ar934x.v2.4.0.cb22320.180904.1044.bin with the SHA256 checksum of
72a0cad06d2c9ca9459ff44c9ae322a5955cfdadc5d7297f7545aa52134e4da3.

.binwalk output for the original image
[listing]
....
â¦iquity_Aircube_Openwrt/orginal 10:17 > binwalk ACB.ar934x.v2.4.0.cb22320.180904.1044.bin

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             Ubiquiti firmware header, header size: 264 bytes, ~CRC32: 0xE1185B2F, version: "ACB.ar934x.v2.4.0.cb22320.180904.1044"
260           0x104           Ubiquiti partition header, header size: 56 bytes, name: "PARTu-boot", base address: 0x00000000, data size: 0 bytes
126916        0x1EFC4         Certificate in DER format (x509 v3), header length: 4, sequence length: 64
142164        0x22B54         U-Boot version string, "U-Boot 1.1.4-s1042 (May 26 2017 - 18:32:46)"
142452        0x22C74         CRC32 polynomial table, big endian
219680        0x35A20         CRC32 polynomial table, big endian
221916        0x362DC         Ubiquiti end header, header size: 12 bytes, cumulative ~CRC32: 0x454E442E
226336        0x37420         Ubiquiti partition header, header size: 56 bytes, name: "PARTkernel", base address: 0x00000001, data size: -2147475456 bytes
226400        0x37460         uImage header, header size: 64 bytes, header CRC: 0xF5AFC58F, created: 2018-09-04 05:28:33, image size: 1280210 bytes, Data Address: 0x80060000, Entry Point: 0x80060000, data CRC: 0x673454B1, OS: Linux, CPU: MIPS, image type: OS Kernel Image, compression type: lzma, image name: "MIPS OpenWrt Linux-4.1.16"
226464        0x374A0         LZMA compressed data, properties: 0x6D, dictionary size: 8388608 bytes, uncompressed size: 4059868 bytes
1506674       0x16FD72        Ubiquiti partition header, header size: 56 bytes, name: "PARTrootfs", base address: 0x00000002, data size: 0 bytes
1506738       0x16FDB2        Squashfs filesystem, little endian, version 4.0, compression:xz, size: 5203098 bytes, 1684 inodes, blocksize: 262144 bytes, created: 2018-09-04 07:28:33
6880754       0x68FDF2        POSIX tar archive (GNU)

â¦iquity_Aircube_Openwrt/orginal 10:17 >
....

This gives quite some information about the image format. First there is a
`Ubiquiti firmware header` with a size of 264 bytes which contains some
information about the whole image. After that there are a number of `Ubiquiti
partition header` blocks with a size of 56 bytes each. It seems that they can
but don't have to be ended by an `Ubiquiti end header`.

==== Ubiquiti firmware header @0x0

----
â¦iquity_Aircube_Openwrt/orginal 10:39 > xxd -g1 -l264 ACB.ar934x.v2.4.0.cb22320.180904.1044.bin
00000000: 55 42 4e 54 41 43 42 2e 61 72 39 33 34 78 2e 76  UBNTACB.ar934x.v
00000010: 32 2e 34 2e 30 2e 63 62 32 32 33 32 30 2e 31 38  2.4.0.cb22320.18
00000020: 30 39 30 34 2e 31 30 34 34 00 63 62 32 32 33 32  0904.1044.cb2232
00000030: 30 64 34 32 66 64 66 64 31 63 38 35 34 31 34 36  0d42fdfd1c854146
00000040: 64 35 30 64 37 39 61 31 32 37 34 32 62 62 35 66  d50d79a12742bb5f
00000050: 63 35 4d 00 00 00 00 00 00 00 00 00 00 00 00 00  c5M.............
00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000100: 00 00 00 00 e1 18 5b 2f                          ......[/
â¦iquity_Aircube_Openwrt/orginal 10:39 >
----

`binwalk` can decode at least part of the header so it seems that it's a known
format. Let's have a look at the sources:

https://github.com/ReFirmLabs/binwalk/tree/0c2412c474fa7

In `src/binwalk/magic/firmware` there is a paragraph describing the format:

----
# Ubiquiti firmware signatures
0       string      UBNT        Ubiquiti firmware header, header size: 264 bytes,
>0x108  belong      !0          {invalid},
>0x104  ubelong     x           ~CRC32: 0x%X,
>4      byte        0           {invalid},
>4      string      x           version: "%s"

0       string      GEOS        Ubiquiti firmware header, header size: 264 bytes,
>0x108  belong      !0          {invalid},
>0x104  ubelong     x           ~CRC32: 0x%X,
>4      byte        0           {invalid},
>4      string      x           version: "%s"

0       string      OPEN        Ubiquiti firmware header, third party,
>0x108  belong      !0          {invalid},
>0x104  ubelong     x           ~CRC32: 0x%X,
>4      byte        0           {invalid},
>4      string      x           version: "%s"
----

So everything starting with the string `UBNT` is a valid firmware header. It
seems that there is also a `OPEN` reserved for third party firmware. After that
some string follows. That's the `ACB.ar934x.v2.4.0.cb22320.180904.1044` part.
The next part (`.cb22320d42fdfd1c854146d50d79a12742bb5fc5M`) isn't described.
But it looks like a git hash with an added M at the end. So most likely that's
part of the version. The following zeros most likely are just reserve for longer
strings followed by a four byte CRC32. The CRC32 is calculated over the complete
header:

----
â¦iquity_Aircube_Openwrt/orginal 10:51 > pycrc --check-hexstring "55424e544143422e6172393334782e76322e342e302e636232323332302e3138303930342e3130343400636232323332306434326664666431633835343134366435306437396131323734326262356663354d000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" --model crc-32
0xe1185b2f
â¦iquity_Aircube_Openwrt/orginal 10:52 >
----

==== Ubiquiti partition headers and end header @0x104, @0x362DC, @0x37420 and @0x16FD72

There are three partition headers and one end header detected in that file. It
seems that binwalk isn't that good in deciphering them. The printed data sizes
are not really plausible and most likely two end headers are missing.

.partition header detection in binwalk
----
-4  string      \x00\x00\x00\x00PART    Ubiquiti partition header,
>0  byte        x                       header size: 56 bytes,
>0  byte        0                       {invalid}
>0  string      x                       name: "%s",
>40 ubelong     x                       base address: 0x%.8X,
>48 belong      x                       data size: %d bytes{size:%d}

-4  string      \x00\x00\x00\x00END\x2e Ubiquiti end header, header size: 12 bytes,
>8  belong      !0                      {invalid},
>4  ubelong     x                       cumulative ~CRC32: 0x%.8X

-4   string      \x00\x00\x00\x00ENDS   Signed Ubiquiti end header, RSA 2048 bit, header size: 264 bytes
>260 ubelong     !0                     {invalid}
----

So a partiton header starts with four zeros and the string `PART`. Let's try to
decypher the partition header and end header by having a look at them:

.header @0x104 (with some before and after)
----
â¦iquity_Aircube_Openwrt/orginal 11:06 > xxd -s 0x100 -g 1 -l128 ACB.ar934x.v2.4.0.cb22320.180904.1044.bin
00000100: 00 00 00 00 e1 18 5b 2f 00 00 00 00 50 41 52 54  ......[/....PART
00000110: 75 2d 62 6f 6f 74 00 00 00 00 00 00 00 00 00 00  u-boot..........
00000120: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000130: 00 00 00 00 9f 00 00 00 00 00 00 00 00 03 72 dc  ..............r.
00000140: 00 04 00 00 10 00 00 ff 00 00 00 00 10 00 00 fd  ................
00000150: 00 00 00 00 10 00 02 19 00 00 00 00 10 00 02 17  ................
00000160: 00 00 00 00 10 00 02 15 00 00 00 00 10 00 02 13  ................
00000170: 00 00 00 00 10 00 02 11 00 00 00 00 10 00 02 0f  ................
â¦iquity_Aircube_Openwrt/orginal 11:06 >
----

Together with the information from binwalk, that header is quite clear: Starting
at 0x108 (not 0x104 like binwalk thinks) there is the magic string
`\x00\x00\x00\x00PART`. After that a partition name (matching the mtd partition
names) follows. In this case it's `u-boot` followed by a lot of space filled
with zeros. Finally starting at an offset of 0x2c (address 0x134), there seems
to be something else: `9f 00 00 00 00 00 00 00 00 03 72 dc 00 04 00 00` followed
by the first bytes that I found in my flash dump of the original system.

The first four bytes are most likely the start address (flash starts to be
addressed at 0x9f000000 on this system; `u-boot` partition is at offset 0). The
last four bytes seem to be the maximum partition size (0x00040000). That leaves
the middle part of `00 00 00 00 00 03 72 dc`. The last four digits could be a
offset from the start of the content to the next header: 0x144 + 0x000372dc =
0x37420. In other words: The size of the content.

Forward to the next header detected by binwalk: The end header at 0x362dc:

.header @0x362DC
----
000362b0: 25 73 27 21 20 28 25 64 29 0a 00 00 0a 46 69 72  %s'! (%d)....Fir
000362c0: 6d 77 61 72 65 20 75 70 64 61 74 65 20 63 6f 6d  mware update com
000362d0: 70 6c 65 74 65 2e 0a 00 2c 00 00 00 50 41 52 54  plete...,...PART
000362e0: 00 00 00 00 45 4e 44 2e 00 00 00 00 55 42 4e 54  ....END.....UBNT
000362f0: 00 00 00 00 47 45 4f 53 00 00 00 00 4f 50 45 4e  ....GEOS....OPEN
00036300: 00 00 00 00 61 72 39 33 34 00 00 00 46 69 72 6d  ....ar934...Firm
00036310: 77 61 72 65 20 56 65 72 73 69 6f 6e 3a 20 25 73  ware Version: %s
00036320: 0a 00 00 00 45 4e 44 53 00 00 00 00 20 52 53 41  ....ENDS.... RSA
00036330: 20 53 69 67 6e 65 64 20 49 6d 61 67 65 2e 20 56   Signed Image. V
00036340: 65 72 69 66 79 69 6e 67 20 70 6c 65 61 73 65 20  erifying please 
----

That is in the middle of some other strings. So most likely it's the text
segment of the U-Boot contained in the update and can be ignored. Let's continue
with the next real header:

.header @0x37420
----
â¦iquity_Aircube_Openwrt/orginal 11:36 > xxd -s 0x373e0 -g 1 -l0x100 ACB.ar934x.v2.4.0.cb22320.180904.1044.bin
000373e0: 80 20 75 7c 80 20 0f 04 80 22 ca 30 80 20 0a 84  . u|. ...".0. ..
000373f0: 80 20 54 38 80 22 cd b0 80 20 09 70 80 20 40 80  . T8."... .p. @.
00037400: 80 22 cb 50 80 22 cd c0 80 20 34 44 80 20 09 00  .".P."... 4D. ..
00037410: 80 20 4a 90 80 20 a3 9c 80 20 77 8c 80 20 a3 38  . J.. ... w.. .8
00037420: 2f 63 41 74 00 00 00 00 50 41 52 54 6b 65 72 6e  /cAt....PARTkern
00037430: 65 6c 00 00 00 00 00 00 00 00 00 00 00 00 00 00  el..............
00037440: 00 00 00 00 00 00 00 00 80 00 20 00 00 00 00 01  .......... .....
00037450: 9f 05 00 00 80 00 20 00 00 13 89 12 00 40 00 00  ...... ......@..
00037460: 27 05 19 56 f5 af c5 8f 5b 8e 18 01 00 13 88 d2  '..V....[.......
00037470: 80 06 00 00 80 06 00 00 67 34 54 b1 05 05 02 03  ........g4T.....
00037480: 4d 49 50 53 20 4f 70 65 6e 57 72 74 20 4c 69 6e  MIPS OpenWrt Lin
00037490: 75 78 2d 34 2e 31 2e 31 36 00 00 00 00 00 00 00  ux-4.1.16.......
000374a0: 6d 00 00 80 00 dc f2 3d 00 00 00 00 00 00 00 6f  m......=.......o
000374b0: fd ff ff a3 b7 7f 4c 34 f7 f8 1f 01 7a 6e db 3c  ......L4....zn.<
000374c0: ec 7d 4e a1 71 42 07 53 5c c0 60 27 e1 7d 34 4d  .}N.qB.S\.`'.}4M
000374d0: 9c eb 47 fe 81 53 55 c3 ab c6 3e 77 88 07 19 20  ..G..SU...>w... 
â¦iquity_Aircube_Openwrt/orginal 11:37 >
----

Right before the header starts with the same format like before, there is a
0x2f634174 that doesn't look like the pattern right before it. Maybe a checksum?
Let's check together with the other headers later.

This time it's partition `kernel`. Unlike before there is already some content
at offset 0x24 (address 0x37448): `80 00 20 00 00 00 00 01`. After that the
already known start address of the partition and the bytes in the already
analyzed order follows.

Let's have a look at the last header:

.header @0x16FD72
----
â¦iquity_Aircube_Openwrt/orginal 12:03 > xxd -s 0x16FD00 -g 1 -l0x100 ACB.ar934x.v2.4.0.cb22320.180904.1044.bin
0016fd00: 6c dc 60 3f d7 f3 f2 c5 38 fa f6 50 db d8 7a 8e  l.`?....8..P..z.
0016fd10: c8 07 18 c3 f0 2e 95 79 ab 03 b0 65 c4 fc ff a7  .......y...e....
0016fd20: 1d 7a c4 19 fe 7f 5c 04 1f a3 96 d9 61 b5 80 27  .z....\.....a..'
0016fd30: d5 96 87 b3 9c 95 03 94 9c ec 0c ca 2b 76 d7 61  ............+v.a
0016fd40: 70 35 c2 49 bf ee 90 b1 a2 b7 f8 e3 2b c3 cb a2  p5.I........+...
0016fd50: 3a 15 d7 db fb 25 c9 6e 06 66 a0 07 3d 1c b4 f6  :....%.n.f..=...
0016fd60: 5d a8 46 aa f6 6d 7f f3 c9 fe 66 c9 28 bd cd 47  ].F..m....f.(..G
0016fd70: 10 1a d1 a2 72 ff 00 00 00 00 50 41 52 54 72 6f  ....r.....PARTro
0016fd80: 6f 74 66 73 00 00 00 00 00 00 00 00 00 00 00 00  otfs............
0016fd90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0016fda0: 00 02 9f 45 00 00 00 00 00 00 00 52 00 00 00 b6  ...E.......R....
0016fdb0: 00 00 68 73 71 73 94 06 00 00 21 34 8e 5b 00 00  ..hsqs....!4.[..
0016fdc0: 04 00 21 00 00 00 04 00 12 00 c0 06 01 00 04 00  ..!.............
0016fdd0: 00 00 7f 06 fa 32 00 00 00 00 9a 64 4f 00 00 00  .....2.....dO...
0016fde0: 00 00 92 64 4f 00 00 00 00 00 ff ff ff ff ff ff  ...dO...........
0016fdf0: ff ff ce da 4e 00 00 00 00 00 ca 0f 4f 00 00 00  ....N.......O...
â¦iquity_Aircube_Openwrt/orginal 12:08 >
----

Here the bytes right after the name are `00 00 00 00 00 00 00 02`. That gives
another hint regarding one word: The last four bytes seem to be a counter.

If the size is added again, to the last header, the next something would be at
0x68fdb2. binwalk detected nothing at this address. Let's have a look:

.something @0x68fdb2
----
â¦iquity_Aircube_Openwrt/orginal 12:21 > xxd -s 0x68fd00 -g 1 -l0x200 ACB.ar934x.v2.4.0.cb22320.180904.1044.bin
0068fd00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fd10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fd20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fd30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fd40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fd50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fd60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fd70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fd80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fd90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fda0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fdb0: 00 00 50 10 09 47 00 00 00 00 45 58 45 43 65 78  ..P..G....EXECex
0068fdc0: 74 72 61 73 00 00 00 00 00 00 00 00 00 00 00 00  tras............
0068fdd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fde0: 00 00 00 00 00 00 00 00 00 00 00 03 70 00 00 03  ............p...
0068fdf0: 70 00 62 69 6e 2f 00 00 00 00 00 00 00 00 00 00  p.bin/..........
0068fe00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fe10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fe20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fe30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fe40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fe50: 00 00 00 00 00 00 30 30 30 30 37 35 35 00 30 30  ......0000755.00
0068fe60: 30 32 37 33 34 00 30 30 30 32 37 33 34 00 30 30  02734.0002734.00
0068fe70: 30 30 30 30 30 30 30 30 30 00 31 33 33 34 33 34  000000000.133434
0068fe80: 33 33 37 32 32 00 30 31 31 35 32 34 00 20 35 00  33722.011524. 5.
0068fe90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fea0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068feb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fec0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fed0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fee0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0068fef0: 00 00 00 75 73 74 61 72 20 20 00 6a 65 6e 6b 69  ...ustar  .jenki
â¦iquity_Aircube_Openwrt/orginal 12:21 >
----

There definitively is something there. The header format starts similar. Instead
of the `PARTxxx`, there is a `EXECextras`. So maybe some executable to do
something. `binwalk` detects a tar archive right at the end of the header at
address 0x68fdf2. Let's have a look:

----
> dd if=ACB.ar934x.v2.4.0.cb22320.180904.1044.bin of=0x68fdf2_to_end.tar bs=1 skip=6880754
> tar tf 0x68fdf2_to_end.tar
bin/
bin/qca953x-u-boot.bin
>
----

Looks like there is an extra binary for updating the boot loader. Let's ignore
it.

There is something Interesting at the end of the file:

.dump of the end of original firmware
----
006c6dd0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
006c6de0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
006c6df0: 0000 4f94 4569 0000 0000 454e 4453 6fd6  ..O.Ei....ENDSo.
006c6e00: f182 4ef7 e0d0 0cf7 0eaf aefb 91f6 09fa  ..N.............
006c6e10: 2672 8351 7166 b3b5 acf5 6edf abdd 8495  &r.Qqf....n.....
006c6e20: 799c 389e 518f f8a2 8801 1c4c d57c 3c39  y.8.Q......L.|<9
006c6e30: 6b6a ab5b db0f 5b1e bb04 76cf 7490 f57a  kj.[..[...v.t..z
006c6e40: 892a 0f67 6229 7223 1c3f 981e 70a0 2d13  .*.gb)r#.?..p.-.
006c6e50: a54a 3868 1d65 1cbf 3815 2e20 19d2 017c  .J8h.e..8.. ...|
006c6e60: 31b7 f2ee 7797 3172 2b61 6f18 ede3 ecf2  1...w.1r+ao.....
006c6e70: 8caa 6d50 c1b4 ba8c 5775 7291 7a87 d3fb  ..mP....Wur.z...
006c6e80: d368 46af 503a 2124 8ce4 ad31 570a 4ca0  .hF.P:!$...1W.L.
006c6e90: 3d75 dddc ac3c 9033 14a4 27c3 fd42 d321  =u...<.3..'..B.!
006c6ea0: ef94 2997 02d0 f7aa 5a88 5daf dc5a 2b52  ..).....Z.]..Z+R
006c6eb0: 1712 1d7e 4fe1 79c8 649c 3e22 2087 5a5d  ...~O.y.d.>" .Z]
006c6ec0: 71ff efbf 9431 02cf 8824 8c68 b4e3 db85  q....1...$.h....
006c6ed0: de12 365a 7f24 6722 5e7e 4995 2c9a 3c73  ..6Z.$g"^~I.,.<s
006c6ee0: 93f8 16c0 9ae7 5e3a 94a0 2670 a0d7 b037  ......^:..&p...7
006c6ef0: 633d 7e90 63ed ce91 4c8c 6dca 0c18 0000  c=~.c...L.m.....
006c6f00: 0000                                     ..
----

There is an `ENDS` header. According to binwalk that could be a signed Ubiquiti
end header. Let's hope that unsingned header works too.

==== Puzzle out the data block format

The collected information till now suggest the following data block format:

- 4 Byte Header type (`UBNT`, `PART`, `EXEC`, `ENDS`; from binwalk: `GEOS`,
  `OPEN`, `END.`)
- Header specific format.
- 4 Byte CRC32
- 4 Byte padding (all zero)

The CRC32 is calculate from the Header type till the end of the block. For
blocks with a size that isn't dividable by 4 some padding is most likely
necessary. To create a custom image, currently I suggest to pad the content with
0xFF.

FIXME: Find out how to calc checksums for odd sizes.

.Header format for `PART` as C structure
----
struct part_hdr {
	uint8_t type[4]; /* "PART" for the partitions. Some other seem possible. */
	uint8_t part_name[28]; /* For "PART": Name of the partition. */
	uint8_t unknown1[4];
	uint8_t header_number[4];
	uint8_t start_address[4];
	uint8_t unknown2[4];
	uint8_t content_size[4];
	uint8_t max_size[4];
}
----

Some fields of the `PART` header remain unknown:

|===
| header number | part_name | unknown1    | unknown2
| 0             | u-boot    | 00 00 00 00 | 00 00 00 00
| 1             | kernel    | 80 00 20 00 | 80 00 20 00
| 2             | rootfs    | 00 00 00 00 | 00 00 00 00
|===

Hopefully they are not necessary to build a custom image.

Interesting part is the END block. According to a question at StackExchange, the
END without a signature consists of `END.`, a CRC over all parts and a 4 Byte
padding: https://reverseengineering.stackexchange.com/a/12758

==== Try to create an image with that format

With that information, a image in the correct format can be generated. That can
be done by the small c-Programm in `fwgen`.

After fixing some bugs with the checksum, the bootloader now prints the
following message:

----
Receiving file from 192.168.1.5:41751
Received 3671068 bytes
Firmware Version: ACB.ar934x
Bad signature!
Firmware check failed! (1)
----

So it seems that it doesn't accept unsigned firmware images.

// === Further analysis of U-Boot
// 
// Sadly the first attempt at creating an image didn't work. So a more thorough
// analysis of the check algorithm is necessary.
// 
// Although Ubiquiti proudly claims that all sources are in the GPL archive, there
// is no download link to it. I asked the support for the archive for the airCube
// in January 2018 and received the following answer: "GPL Source code for airCube
// is not available for now and we do not have any ETA when it will be available."
// 
// Three months later, the GPL archive is still not downloadable. So the binary has
// to be enough ...
// 
// It's quite unclear which parts of the system are GPL and which are not. It's
// quite possible that Ubiquiti wrote their own program for checking the image that
// isn't linked against any GPL code. Analyzing that could be a violation of the
// EULA. So let's ignore the web interface upgrade.
// 
// Luckily U-Boot is quite clearly GPL and the code that checks the image there has
// to be linked into the one U-Boot binary. So it can't violate any copyrights to
// analyze the U-Boot. GPL clearly allows analysis.
// 
// To be entirely sure that there is no license violation, I'll extract the U-Boot
// that I took from the flash dump. I don't have to accept any EULA for opening the
// device and attaching to the serial console. But I can dump the flash that way.
// So there shouldn't be any problems there.
// 
// U-Boot is in the first partition starting at flash offset 0x0. The size of that
// partition is 0x40000 (256k):
// 
// ----
// > dd if=orgflash.bin of=orgflash.u-boot.bin bs=1k count=256
// ----
// 
// The result is a binary. To analyze it further, some knowledge about the
// processor and structure is necessary.
// 
// ==== Architecture, Endianess and Code Entry point
// 
// First things first: The processor is a MIPS. According to
// https://wikidevi.com/wiki/Qualcomm_Atheros it's a MIPS 24Kc. There is also a
// note there that it "appears to be identical to the QCA9531"
// 
// I would expect that the binary begins with a vector table:
// 
// ----
// > xxd -g4 orgflash.u-boot.bin
// 00000000: 100000ff 00000000 100000fd 00000000  ................
// 00000010: 10000175 00000000 10000173 00000000  ...u.......s....
// 00000020: 10000171 00000000 1000016f 00000000  ...q.......o....
// 00000030: 1000016d 00000000 1000016b 00000000  ...m.......k....
// 00000040: 10000169 00000000 10000167 00000000  ...i.......g....
// 00000050: 10000165 00000000 10000163 00000000  ...e.......c....
// 00000060: 10000161 00000000 1000015f 00000000  ...a......._....
// 00000070: 1000015d 00000000 1000015b 00000000  ...].......[....
// 00000080: 10000159 00000000 10000157 00000000  ...Y.......W....
// 00000090: 10000155 00000000 10000153 00000000  ...U.......S....
// 000000a0: 10000151 00000000 1000014f 00000000  ...Q.......O....
// 000000b0: 1000014d 00000000 1000014b 00000000  ...M.......K....
// 000000c0: 10000149 00000000 10000147 00000000  ...I.......G....
// 000000d0: 10000145 00000000 10000143 00000000  ...E.......C....
// 000000e0: 10000141 00000000 1000013f 00000000  ...A.......?....
// 000000f0: 1000013d 00000000 1000013b 00000000  ...=.......;....
// 00000100: 10000139 00000000 10000137 00000000  ...9.......7....
// 00000110: 10000135 00000000 10000133 00000000  ...5.......3....
// 00000120: 10000131 00000000 1000012f 00000000  ...1......./....
// 00000130: 1000012d 00000000 1000012b 00000000  ...-.......+....
// ----
// 
// Looks quite like a table. MIPS can use big or little endian format. The table
// most likely contains jump instructions.
// 
// MIPS instructions always start with a 6 bit opcode. Depending on the type of the
// opcode, different fields can follow. Take a look at
// https://github.com/MIPT-ILab/mipt-mips/wiki/MIPS-Instruction-Set (or some other
// reference) for details.
// 
// U-Boot drivers are (mostly) polled. So most vectors should point to some default
// routine. The dump of the vector table above shows a lot of numbers counting
// down (except for the first two vectors). So most likely the instruction is some
// kind of relative jump followed by an address. That gives a hint about the
// endianness: The instruction (highest bits) are at the lowest address. So We are
// talking *big-endian* here.
// 
// The instruction is a 0b000100 which is a branch on equal (`beq`). `beq` is
// followed by 5 bit source (`s`), 5 bit target (`t`) and a 16 bit immediate value
// (`C`). It does the following:
// 
// ----
// PC += 4;
// if (s == t)
//     PC += (C << 2)
// ----
// 
// `s` and `t` are pointing to the same field. So its used more or less
// unconditional here. For the reset vector (the first one) the jump goes to `PC =
// PC + 4 + (0xFF << 2) = <start address> + 0x400`. So the program entry is at
// 0x9F000400.
// 
// ==== Disassembly
// 
// With that information gathered, let's try to disassemble the code.
// 
// Sadly objdump doesn't like binaries without additional information. So some
// extra parameters are necessary:
// 
// ----
// > mips-openwrt-linux-objdump -mmips:isa32r2 -b binary -EB --adjust-vma=0x9f000000 -Mreg-names=mips32r2 -D orgflash.u-boot.bin > orgflash.u-boot.bin.disassembly
// ----
// 
// That of course is still quite hard to read from the beginning. To get to the
// right location, the string printed during a failed check might would be useful:
// `Firmware check failed! (1)`. That is located at address 0x9f027250.
// 
// Of course no one loaded that address directly. Most likely some load via a
// pointer before it is passed to the print function.

=== Flashing via U-Boot

With (currently) no other options left lets try to flash via U-Boot.

----
ath> setenv serverip 192.168.1.100
ath> help tftpboot
tftpboot [loadAddress] [bootfilename]

ath> tftpboot 0x81000000 openwrt-ath79-generic-ubnt_acb-isp-squashfs-sysupgrade.bin
eth0 link down
enet1 port1 up
dup 1 speed 1000
Using eth1 device
TFTP from server 192.168.1.100; our IP address is 192.168.1.20
Filename 'openwrt-ath79-generic-ubnt_acb-isp-squashfs-factory.bin'.
Load address: 0x81000000
Loading: #################################################################
         #################################################################
         #################################################################
         #################################################################
         #################################################################
         #################################################################
         #######
done
Bytes transferred = 2031620 (1f0004 hex)
ath> erase 0x9f050000 0x9ffaffff
Erasing flash... 
First 0x5 last 0xfa sector size 0x10000
 250
Erased 246 sectors
ath> cp.b 0x81000000 0x9f050000 ${filesize}
Copy to Flash... write addr: 9f050000
done
ath> reset
----

After that, the OpenWRT system boots.

NOTE: Originally I used `cp` instead of `cp.b` here. That copies `${filesize}`
word instead of the same amount of bytes.

=== Searching for alternative flashing methods

Flashing via U-Boot is not really a good solution because it is necessary to
open the case. So some method to work around that is necessary.

Again: This analysis is done on version
`ACB.ar934x.v2.4.0.cb22320.180904.1044.bin`

==== Inject commands

Some method to inject commands via the web interface is necessary. One
possibility is the configuration update:

The configuration archive that can be downloaded from the device is quite
simple: Rename it to something ending on .tar.gz and it can be extracted.

The archive contains the contents of +/tmp/persistent/config/+ which is mounted
to +/etc/config/+. One vulnerable service there is the uhttpd service with the
lua module.

*ATTENTION: The following breaks the original web interface.*

In the file +uhttpd+ the following configs can be changed to the given new
values:

----
option lua_prefix  '/lua'
option lua_handler '/tmp/persistent/config/upgrade/lua_handler.lua'
----

Now every time +http://192.168.1.1/lua+ is opened the script +upgrade/lua_handler.lua+
that can be packed together with the configuration is called.

That script can look like follows:

----
local hex_to_char = function(x)
  return string.char(tonumber(x, 16))
end

local unescape = function(url)
  return url:gsub("%%(%x%x)", hex_to_char)
end

function handle_request(env)
    uhttpd.send("Status: 200 OK\r\n")
    uhttpd.send("Content-Type: text/html\r\n\r\n")

    local command = unescape(string.sub(env.REQUEST_URI, 6))

    local proc = assert(io.popen(command))
    for line in proc:lines() do
        uhttpd.send(line.."\n")
    end
    proc:close()
end
----

The +local command+ is here set with the later part of the URL and can be
replaced by any shell command.

For this script, the following curl command can be used to run any command (hURL
is a simple URL encoder - any other can be used):

----
curl -k 'https://192.168.1.1/lua/'`hURL --nocolor -s -U "ls /etc 2>&1"`
----

==== Change U-Boot environment

Now it should theoretically be possible to change the U-Boot environment using
the ability to inject commands. Ubiquiti was nice enough to provide the
+uboot-envtools+ package with +fw_printenv+ and +fw_setenv+ commands. But the
configuration is missing. It is not enough to set the +/etc/config/ubootenv+.
Normally a +/etc/fw_env.config+ should be generated but for some reason is
doesn't on that device. So it has to be added manually.

Unluckily +/etc+ is on a squashfs and Ubiquiti didn't add an OverlayFS for it.
So it's not changeable. But a temporary OverlayFS can be added:

----
mkdir -p /tmp/root
mkdir -p /tmp/overlay
mkdir -p /tmp/overlay_work
mount -t squashfs -oro /dev/mtdblock3 /tmp/root
mount -t overlay -o lowerdir=/tmp/root/etc,upperdir=/tmp/overlay,workdir=/tmp/overlay_work overlay /etc
----

Now the configuration can be created and the environment is readable and
writeable:

----
ubnt@airCube-ISP:/etc# echo "/dev/mtd1 0x0 0x10000 0x10000" >> /etc/fw_env.config
ubnt@airCube-ISP:/etc# fw_printenv 
bootdelay=1
baudrate=115200
ethaddr=0x00:0xaa:0xbb:0xcc:0xdd:0xee
ubntctrl=enabled
serverip=192.168.1.254 
stdin=serial
stdout=serial
stderr=serial
ubntaddr=80200020
appinitdone=true
ethact=eth1
mtdparts=mtdparts=spi0.0:256k(u-boot),64k(u-boot-env),4096k(kernel),11648k(rootfs),256k(cfg),64k(EEPROM)
bootcmd=bootm 0x9f050000
bootargs=console=ttyS0,115200 root=31:03 rootfstype=squashfs init=/sbin/init panic=3 board=AIRCUBE
ipaddr=192.168.1.20
ubnt@airCube-ISP:/etc#
----

Now for a useful new U-Boot bootcmd: This should consist of multiple parts:

1. Show the user that he can do something via LED.
2. Wait some seconds for the reset button.
3. If pressed: Do something useful like a net console. Otherwise boot normally.

Relevant GPIO pins for that are (see earlier analysis):

* LED CS: GPIO 1
* LED MOSI: GPIO 2
* LED SCK: GPIO 3
* Reset button: GPIO 17

The LED is connected to some GPIO pins. So the first thing would be to control
these via some small function. It is necessary to use the raw registers because
the Ubiquiti didn't add any GPIO functions.

Unfortunately the U-Boot shell is very minimalistic. So the commands have to be
minimalistic. Let's assume the following:

- Someone already set the LED and therefore the pins are initialized.
- Someone already read the Reset button and therefore the pin is initialized.

.U-Boot command sequences for setting the LED
----
setenv LEDcs0 mw.l 0x18040010 0x00000002
setenv LEDcs1 mw.l 0x1804000C 0x00000002
setenv LEDck0 mw.l 0x18040010 0x00000008
setenv LEDck1 mw.l 0x1804000C 0x00000008
setenv LEDda0 mw.l 0x18040010 0x00000004
setenv LEDda1 mw.l 0x1804000C 0x00000004
setenv LEDb0 'run LEDda0; run LEDck1; run LEDck0'
setenv LEDb1 'run LEDda1; run LEDck1; run LEDck0'
setenv LEDsend1 'run LEDb0; run LEDb0; run LEDb0; run LEDb1'
setenv LEDsend4 'run LEDb0; run LEDb1; run LEDb0; run LEDb0'
setenv LEDsend5 'run LEDb0; run LEDb1; run LEDb0; run LEDb1'
setenv LEDsend41 'run LEDcs0; run LEDsend4; run LEDsend2; run LEDcs1'
setenv LEDsend55 'run LEDcs0; run LEDsend5; run LEDsend5; run LEDcs1'
run LEDsend41
----

Setting the LED with this commands work for at least some values. It seems that
for some reason the uppermost bit can't be one. But it's enough to show some
states so it's OK.

A bigger problem is the check for the reset button: It seems that Ubiquiti
decided to build a U-Boot without +if+ or similar. Luckily there is an +cmp+
command which can be used to execute a command conditionally.

.U-Boot command sequences for reading the reset button
----
setenv BTNcopy 'cp.b 0x18040005 0x81000000 1'
setenv BTNmaybeCmd 'echo do this if not pressed'
setenv BTNallwaysCmd 'echo always do this'
setenv BTNcheck 'cmp.b 0x18040005 0x81000000 1'
run BTNcopy; echo 'press reset now ...'; sleep 3; run BTNcheck BTNmaybeCmd; run BTNallwaysCmd
----

So with that there is the possibility of indication (LED) and detecting user
input (reset button). Now only something useful is missing.

It seems that Ubiquiti also decided that a netconsole wouldn't be worth the
effort. So the commands have to do all of the flashing work if reset is pressed.

==== Putting it together

Putting it all together, the following script should be injected:

----
#!/bin/sh -x

# prepare environment for fw_setenv
mkdir -p /tmp/root
mkdir -p /tmp/overlay
mkdir -p /tmp/overlay_work
mount -t squashfs -oro /dev/mtdblock3 /tmp/root
mount -t overlay -o lowerdir=/tmp/root/etc,upperdir=/tmp/overlay,workdir=/tmp/overlay_work overlay /etc
echo "/dev/mtd1 0x0 0x10000 0x10000" >> /etc/fw_env.config

# create U-Boot variable file
cat <<EOF > /tmp/ubootenv_add
LEDcs0         mw.l 0x18040010 0x00000002
LEDcs1         mw.l 0x1804000C 0x00000002
LEDck0         mw.l 0x18040010 0x00000008
LEDck1         mw.l 0x1804000C 0x00000008
LEDda0         mw.l 0x18040010 0x00000004
LEDda1         mw.l 0x1804000C 0x00000004
LEDb0          run LEDda0; run LEDck1; run LEDck0
LEDb1          run LEDda1; run LEDck1; run LEDck0
LEDsend1       run LEDb0; run LEDb0; run LEDb0; run LEDb1
LEDsend4       run LEDb0; run LEDb1; run LEDb0; run LEDb0
LEDsend5       run LEDb0; run LEDb1; run LEDb0; run LEDb1
LEDsend41      run LEDcs0; run LEDsend4; run LEDsend1; run LEDcs1
LEDsend45      run LEDcs0; run LEDsend4; run LEDsend5; run LEDcs1
LEDsend55      run LEDcs0; run LEDsend5; run LEDsend5; run LEDcs1
UPSrvIP        setenv serverip 192.168.1.100
UPTFTP         tftpboot 0x81000000 openwrt-sysupgrade.bin
UPerase        erase 0x9f050000 0x9ffaffff
UPcp           cp 0x81000000 0x9f050000 ${filesize}
BTNcopy        cp.b 0x18040005 0x81000000 1
BTNmaybeCmd    run LEDsend55; bootm 0x9f050000
BTNallwaysCmd  echo 'try to upgrade now'; run LEDsend41 UPSrvIP UPTFTP UPerase UPcp
BTNcheck       cmp.b 0x18040005 0x81000000 1
bootcmd        run BTNcopy; echo 'press reset now to go into OpenWRT load mode ...'; run LEDsend45; sleep 3; run BTNcheck BTNmaybeCmd; run BTNallwaysCmd; reset
EOF

# write that to Uboot environment
fw_setenv -s /tmp/ubootenv_add
fw_printenv
reboot
----

With that the device will reboot. During the reboot U-Boot will now blink fast
for three seconds. If nothing happens during the three seconds, the device will
continue to boot normally. If the reset button is pressed in this time and hold
till the three seconds are over, an TFTP-re-flash process will be started. This
process expects a 'openwrt-sysupgrade.bin' on a TFTP server at '192.168.1.100'.
It takes that image and flashes it.

NOTE: There are no error checks. So if the image is wrong or too big, you might
brick your device permanently.

*Problem: This still does not work.* `fw_setenv` seems to have problems
accessing mtd1 if run from the web-if.

=== Searching for alternative flashing methods Part 2

After a long time I decided to continue my Odysee.

The OpenWRT forum user Snap has found out that the `ubntbox` binary can be
patched. See the following link for his explanation:

https://forum.openwrt.org/t/add-openwrt-support-for-ubiquity-aircube-isp-ubnt-acb-isp/32999/22

Basically for a 2.5.0 firmware the byte 0x6016 (=24598) of `ubntbox` has to be
changed to 0x10. So first step: Updating the system to 2.5.0.

With this information the following approach can be tried:

* Inject a script like already described above.
* Mount an overlay file system.
* Patch `ubntbox` and maybe some further files so an unsigned firmware is
  accepted.
* Restore the old web interface.
* Upload a (maybe specially packed) OpenWRT firmware via the normal web
  interface.

==== Preparation

The binary must not be distributed outside of the firmware due to license
reasons. So to be sure it's the right one a md5 check is necessary.

----
ubnt@airCube-ISP:/# md5sum /sbin/ubntbox 
c33235322da5baca5a7b237c09bc8df1  /sbin/ubntbox
----

The BusyBox on the original system knows a `dd`. So let's try to use it to patch
the binary. For reference: If patched with a hex editor on the PC the md5 sum is
`994b91bdd47d0d4770f91487199af6e9`.

----
# Make a working copy for experiments
ubnt@airCube-ISP:~# cd /tmp/
ubnt@airCube-ISP:/tmp# cp /sbin/ubntbox .

# Try to patch it
ubnt@airCube-ISP:/tmp# echo -en '\x10' | dd of=ubntbox conv=notrunc bs=1 count=1 seek=24598
1+0 records in
1+0 records out
ubnt@airCube-ISP:/tmp# md5sum ubntbox
994b91bdd47d0d4770f91487199af6e9  ubntbox
ubnt@airCube-ISP:/tmp#
----

Well, that was easy. Let's put it in a script.

==== Creating the config

Starting point is a a 2.5.0 setup with a factory default config. To make the
configuration a bit more re-usable, the password is changed to an ultra secure
`password`. Then just download configuration via the web interface. The result
is a `.cfg` file which really is a tar gz archive. Change the name to something
like `config.tgz`. After that it can be extracted. Now there is the following
configuration file structure:

----
.
âââ dhcp
âââ dropbear
âââ firewall
âââ led
âââ linux
âÂ Â  âââ passwd
âÂ Â  âââ shadow
âÂ Â  âââ version
âââ network
âââ rpcd
âââ system
âââ ubnt
âââ ubootenv
âââ udapi_bridge
âââ uhttpd
âââ upnpd
âââ wireless
----

The interesting one is `uhttpd` because it configures the web interface. In my
earlier approach I replaced the original web interface. Let's try something
different now: Add a second interface. Currently the file looks like follows:

----
config 'uhttpd' 'main'
	list listen_http    0.0.0.0:80
	list listen_http    [::]:80
	list listen_https '0.0.0.0:443'
	list listen_https '[::]:443'
	option redirect_https   1
	option 'home'        '/usr/www'
	option ubus_prefix '/ubus'
	option lua_prefix  '/api'
	option lua_handler '/usr/lib/cgi/main'

config cert defaults
	option days '730'
	option bits '1024'
	option country 'US'
	option state 'LA'
	option location 'LA'
	option commonname 'Ubiquiti'
----

We just need another section for a custom lua handler. Just put the following
lines in front:

----
config 'uhttpd' 'other'
	list listen_http    0.0.0.0:8080
	list listen_http    [::]:8080
	option 'home'       '/tmp/persistent/config/patch/www'
	option lua_prefix   '/lua'
	option lua_handler  '/tmp/persistent/config/patch/handler.lua'
----

This opens a second web server on port 8080. The files for it are in the
`patch/www` sub directory of the configuration. Due to the fact that access
rights are stripped when uploading a config, this directory is quite useless.
The lua handler is in `patch/handler.lua`. It is called via
`http://192.168.1.1/lua`.

The lua handler is quite simple. It just executes a shell script that does
the real work:

.patch/handler.lua
----
function handle_request(env)
    uhttpd.send("Status: 200 OK\r\n")
    uhttpd.send("Content-Type: text/plain\r\n\r\n")

    local command = "/bin/sh /tmp/persistent/config/patch/patch.sh 2>&1"

    local proc = assert(io.popen(command))
    for line in proc:lines() do
        uhttpd.send(line.."\r\n")
    end
    proc:close()
end
----

Now to the script. That one is really a bit longer but should still be clear. My
initial version had a naming conflict in the LOWERDIR for the overlay. It
accidentally used the same name that is used for the ramfs in `sysupgrade`. That
lead to a lot confusion.

.patch/patch.sh
----
#!/bin/sh -x

set -e
set -u
set -x

UBNTBOX_PATCHED="/tmp/fwupdate.real"
MD5FILE="/tmp/patchmd5"

cat <<EOF > ${MD5FILE}
c33235322da5baca5a7b237c09bc8df1  /sbin/fwupdate.real
EOF

# check md5 of files that will be patched
if ! md5sum -c ${MD5FILE}
then
        echo "******** Error when checking files. Refuse to do anything. ********"
        exit 0
fi

# prepare some overlay functionality
LOWERDIR="/tmp/lower_root"
mkdir -p ${LOWERDIR}
mount -t squashfs -oro /dev/mtdblock3 ${LOWERDIR}
overlay_some_path()
{
        PATH_TO_OVERLAY=$1
        ALIAS=$2
        UPPERDIR="/tmp/over_${ALIAS}"
        WORKDIR="/tmp/over_${ALIAS}_work"

        mkdir -p ${UPPERDIR}
        mkdir -p ${WORKDIR}

        mount -t overlay -o lowerdir=${LOWERDIR}${PATH_TO_OVERLAY},upperdir=${UPPERDIR},workdir=${WORKDIR} overlay ${PATH_TO_OVERLAY}
}

# patch the ubntbox binary.
overlay_some_path "/sbin" "sbin"
echo -en '\x10' | dd of=/sbin/fwupdate.real conv=notrunc bs=1 count=1 seek=24598

echo "******** Done ********"
----

All prepared. Repack everything into a `patch_signaturecheck_config.tgz`. Be
careful not to add a extra file system layer but keep the original layout. Now
upload the config via the web interface. Wait some time (about a minute) till
the uhttpd restart. After that go to http://192.168.1.1:8080/lua. You should see
the output of the patch.sh script with a `Done` at the end. Now the web
interface accepts an unsigned binary.

== Status

- working:
  - OpenWRT booting
  - Basic WLAN function
  - Switch is set up
  - Ethernet WAN / LAN
  - Upgrade via sysupgrade
  - Reset-Button
- untested:
  - PoE
  - PoE pass through
  - Doing something more with WLAN than connect one client
- missing:
  - LED
  - factory upgrade via web IF or TFTP recovery

== 2021: New firmware > 2.8

The manufacturer decided that it would be a good idea to update their signing
keys for their firmware. With Firmware 2.8.0 they introduced a new U-Boot
version that doesn't accept firmware that is signed with the old key. So as soon
as a device has 2.8.0, it is not possible to downgrade it to 2.8.0 (which is
still signed with the old key) or older. Only upgrades to 2.8.1 or newer are
possible. 2.8.1 is not on their website. So all following analysis will be done
on 2.8.3.

=== Running the script

For 2.5.0, a script has been injected via `uhttpd`. For the new version, they
seem to use `lighttpd` for the web interface and as a https proxy to `uhttpd`
for some API use cases. For that port 8080 is now used internally. But it seems
that it is no problem to use (for example) port 8000 instead.

=== ubntbox

In 2.8.3 a different ubntbox is used. The patch for the 2.5 doesn't work any
more. But with the same method that Snap used back for 2.5, it's not too hard to
find a new patch: Now we need a 0x65 0x00 at address 0x6774:

----
> md5sum ubntbox
f6b3a605704f3d8d8ed489f4a5f20584  ubntbox
> echo -en '\x65\x00' | dd of=ubntbox conv=notrunc bs=1 count=2 seek=26484
2+0 records in
2+0 records out
> md5sum ubntbox
126e824822980f42fc46707e9c5203ad  ubntbox
----

That removes the signature check. But a second problem is that a firmware
downgrade is not allowed. Unfortunately the OpenWRT image tells that it is a
2.5.0 firmware. So we need a second patch: A 0x10 at address 0x63f2.

----
> echo -en '\x10' | dd of=ubntbox conv=notrunc bs=1 count=1 seek=25586
1+0 records in
1+0 records out
> md5sum ubntbox
63bf3d56f37f8403dfc3042abd620247  ubntbox
----

With these two adaptions, the remaining part works like before.
